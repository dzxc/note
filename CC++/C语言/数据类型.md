# C语言数据类型

C 语言中的数据类型可分为 4 种，分别是基本类型、构造类型、指针类型、空  
类型  
![](/CC++/C语言/images/data_type.png)

### 整型变量

整型顾名思义就是数据整存整取的类型，32位CPU连接到内存上有32根线，同一时刻CPU读取的数据就是32根线里面的高低电平，也就是32个1 或0 的状态，这些状态转为数据就是整形。  
整型就是一个不包含小数部分的数。在 C 语言中，根据数值的取值范围，可以将整型定义为短整型\(short int\)、基本整型\(int\) 和长整型\(long int\)。  
![](/CC++/C语言/images/data_byte.png)  
需要注意的是，整型数据在内存中占的字节数与所选择的操作系统有关。虽然 C 语言标准中没有明确 规定整型数据的长度，但 long 类型整数的长度不能短于 int 类型，short 类型整数的长度不能长于 int 类型

### 关于整型变量在内存中所占字节数

1. 早期的操作系统是16位系统，  
   int用二字节表示，范围是-32768~32767；  
   long用4字节表示，范围是-2147483648~2147483647。

2. 32位操作系统，  
   int 用4字节表示，与long相同。

3. 64位操作系统，但因程序编译工艺的不同，两者表现出不同的差别：  
   32位编译系统：int占四字节，与long相同。  
   64位编译系统：int占四字节，long占8字节，long数据范围变为：$$-2^{63} $$~ $$2^{63} -1$$

### 实型变量

实型变量也可以称为浮点型变量，浮点型变量是用来存储小数数值的。在 C 语言中，浮点型变量分为 两种:单精度浮点数\(float\)、双精度浮点数\(double\)，但是 double 型变量所表示的浮点数比 float 型变 量更精确。表中举了两种不同浮点型数所占用的存储空间大小及取值范围

### IEEE 754

IEEE定义了多种浮点格式，但最常见的是三种类型：单精度、双精度、扩展双精度，分别适用于不同的计算要求。一般而言，单精度适合一般计算，双精度适合科学计算，扩展双精度适合高精度计算。一个遵循IEEE 754标准的系统必须支持单精度类型（强制类型）、最好也支持双精度类型（推荐类型），至于扩展双精度类型可以随意。  
C语言中float遵循IEEE 2.24 （单精度） double遵循IEEE64.53（双精度）

|  | 长度 | 符号 | 指数 | 尾数 | 有效位数 | 指数偏移 | 说明 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 单精度 | 32位 | 1 | 8 | 23 | 24 | 127 | 有1个隐含位 |
| 双精度 | 64位 | 1 | 11 | 52 | 53 | 1023 | 有1个隐含位 |
| 扩展双精度 | 80位 | 1 | 15 | 64 | 64 | 16383 | 没有隐含位 |

扩展双精度类型没有隐含位，因此它的有效位数与尾数位数一致，而单精度类型和双精度类型均有一个隐含位，因此它的有效位数比位数位数多一个。

IEEE标准通过指数将表示空间划分成了三大块：

1. 最小值指数（所有位全置0）用于定义0和弱规范数
2. 最大指数（所有位全值1）用于定义±∞和NaN（Not a Number）
3. 其他指数用于表示常规的数。

这样一来，最大（指绝对值）常规数的指数不是全1的，最小常规数的指数也不是0，而是1。

#### 单精度类型
无论是单精度还是双精度在存储中都分为三个部分：

1. 符号位(Sign) : 0代表正，1代表为负
2. 指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储
3. 尾数部分（Mantissa）：尾数部分

![](/CC++/C语言/images/float_32.png)
##### 表示范围
|  | 指数 | 尾数 | 数值 |
| :--- | :--- | :--- | :--- |
| 最大数 | 0xFE | 0x7FFFFF | 3.4028234663852886E+38 |
| 最小数 | 0x01 | 0x000000 | 1.1754943508222875E-38 |
| 最小弱规范数 | 0x00 | 0x000001 | 1.4012984643248171E-45 |

注意 **float double 绝对值最小的数值不是0，而是最小弱规范数**
##### 有效数字

单精度类型有24位有效位，因此有效数字是0.301×24=7.2，即单精度类型有7~8位有效数字


### 双精度类型
![](/CC++/C语言/images/float_64.png)
#### 表示范围
|  | 指数 | 尾数 | 数值 |
| :--- | :--- | :--- | :--- |
| 最大数 | 0x7FE | 0xFFFFFFFFFFFFF | 1.7976931348623157E+308 |
| 最小数 | 0x01 | 0x0000000000000 | 2.2250738585072014E-308 |
| 最小弱规范数 | 0x00 | 0x0000000000001 | 4.9406564584124654E-324 |


##### 有效数字
双精度类型有53位有效位，因此有效数字是0.301×53=15.9，即单精度类型有15~16位有效数字。

#### 扩展双精度类型
表面上看，常见的计算一般无需使用扩展双精度类型，因此扩展双精度类型很少见，但这很可能是个错觉。一些浮点硬件（例如 Intel x87 FPU）将扩展双精度类型作为内部格式，即在计算前，其他浮点格式均需转换为扩展双精度类型，然后才进行计算，在输出计算结果时，又将扩展双精度类型转换为其他格式。甚至可以说，扩展双精度类型是最常用的格式，只是一般用户不常见到而已。

#### 表示范围
|  | 指数 | 尾数 | 数值 |
| :--- | :--- | :--- | :--- |
| 最大数 | 0x7FFE | 0xFFFFFFFFFFFFFFFF | 1.18973149535723176E+4932 |
| 最小数 | 0x0001 | 0x0000000000000000 | 3.36210314311209552E-4932 |
| 最小弱规范数 | 0x0000 | 0x0000000000000001 | 1.82259976594123730E-4951\* |




### 分类
| 指数 |  | 隐含位 | 尾数 | 说明 |
| :--- | :--- | :--- | :--- | :--- |
| 111...111 | QNaN | 1 | 1XX...XXX | 尾数高位为1,但尾数不为0 |
|  | SNaN | 1 | 0XX...XXX | 尾数高位为0,但尾数不为0 |
|  | 无穷（∞） | 1 | 0 | 尾数不0 |
|  | 有限数 | 1 | XXX...XXX | 指数非0、非全1 |
| 000...000 | 弱规范数 |  | XXX...XXX | 没有隐含位，尾数不是0 |
|  | 零（0） | 0 | 0 | 尾数为0 |

##### 有限数

在这几类数中，有限数是最常用的，也是唯一以常规方式解释的数。有限数的特征是指数在最大值和最小值之间，且整数位恒是1。例如对于单精度类型，它的指数有8位，考虑偏移后，指数最大值是255，最小值是0，而有限数的指数就在[1，254]区间。整数位是隐藏的，恒是1。它的形式是：

$$±( 1 + f )*2^{E-OFFSET}$$

其中，E是指数，OFFSET是指数偏移，1是被隐含的整数位，f是尾数其他部分。

有限数的使用除了遵循数学规则之外，没有其它规则。当然，有些出于硬件考虑附加的限制是存在的，例如计算正弦函数的FSIN指令就对输入的数据范围施加了限制。

除了违反数学规则之外，在一般使用有限数的过程中，最常见的问题是溢出，即运算结果超出了有限数的表示范围。浮点数长度越小这个问题越常见，例如单精度类型。不过，只要稍微注意一下，一般不是大问题。


#### 0

0的特征是指数、尾数、整数位全0，只有符号位可能不是0。它的形式是：

$$±( 0 + 0 )×2^{0-OFFSET}$$

与数学中0无正负不同，IEEE 754标准定义的0有正负，即0有两种：+0和-0。之所以如此，有几个原因：

[1] 被零除通常产生无穷，而无穷有正负无穷两类；

[2] CopySign函数可以无需特别处理；

以上每个原因都不是绝对要求（毕竟，数学上0无正负就意味着0可以没有符号），但在软硬件实现上给0加上符号却带来一些方便。不过，这也意味着比较指令需要特别注意，因为+0和-0应相等，而不是+0大于-0。

##### 弱规范数
弱规范数的指数与0一样是0，它整数位也是0，但尾数部分不是0。它的形式是：

$$±( f )*2^{0-OFFSET}$$

但此处的f不局限于[0,1)，而是(0,2)。

IEEE标准引入弱规范数的目的是实现一种称为“逐渐下溢”的技术。在计算过程中，如果中间结果小于最小的有限数却不是0（即出现下溢），当作0处理会导致计算终止（例如病态矩阵）。引入弱规范数以后，在0和最小的有限数之间相当一部分数可以表示为弱规范数，从而提高了计算能力。例如单精度类型最小的有限数是1.1754943508222875E-38，而最小的弱规范数是1.4012984643248171E-45。

### ∞

∞的指数部分是最大值，整数位是1，尾数部分是0。它的形式是：

$$±( 1 + 0 )*2^{MAX-OFFSET}$$

因此∞有两类，即+∞和-∞。产生∞的一般情形有：

[1] ∞自身运算，例如-∞+1.0得到-∞；

[2] 被0除，例如1/+0得到+∞；

[3] 上溢，即计算结果超出了类型范围，通过舍入得到∞。

由于在一般数学中，∞是不能参与运算的，因此IEEE的这些规定可以说是某种扩展。

 

#### NaN

NaN的意思是Not a Number或者Not any number。NaN之所以显得比较奇怪，是因为数学上本没有这么一个数或符号，它纯粹是为了方便处理而提出来的，但它的历史可不短。早在三十年代后期就有人提出了类似NaN的概念。1963年的CDC 6600系统实现了它，但将它视为“没有定义”。后来，DEC的PDP-11和VAX系统也使用它，但将它用作“保留的操作数”。时至今日，虽然IEEE明确地定义了NaN，但在实际使用过程中，NaN经常被误解误用，需要特别小心。

与∞一样，NaN的指数部分是最大值，整数位是1，但它尾数部分不是0。它的形式是：

$$±( 1 + f )*2^{MAX-OFFSET}$$

其中，f≠0。

NaN有两类，一类是QNaN（Quiet NaN），一类是SNaN（Signal NaN）。两者的不同在于IEEE标准要求，如果SNaN参与运算要触发非法操作异常，而QNaN参与运算可以不触发异常。两者在格式上的区别在于，QNaN的尾数最高位是1，而SNaN的尾数最高位是0。一般情形下，如果不特别声明，NaN指的是QNaN。

IEEE标准引入NaN的目的是希望给编译器等系统一个约定的值设置未初始化的数据，或者在计算出问题时可以返回一个东西提示计算出现了问题。

##字符型变量
字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，其中每个字符变量都会占用 1 个字节。 在给字符型变量赋值时，需要用一对英文半角格式的单引号(' ')把字符括起来，例如，'A'的声明方式如 下所示:
      char ch = 'A'; //为一个char类型的变量赋值字符'a'

需要注意的是，除了可以直接从键盘上输入的字符(如英文字母，标点符号，数字，数学运算符等) 以外，还有一些字符是无法用键盘直接输入的，比如，“回车”，此时需要采用一种新的定义方式——转 义字符，它以反斜杠\开头，随后接特定的字符

|转义字符| 对应字符 |ASCII码表中的值|
|----|----|----|
|'\t' | 制表符(Tab 键)| 9|
|'\n'| 换行 |10 |
|'\r'| 回车 |13|
|'\"'| 双引号 |34|
|'\''| 单引号 |39|
|'\\'| 反斜杠 |92|


##枚举类型变量
在日常生活中有许多对象的值是有限的，可以一一列举出来。例如一个星期内只有七天、一年只有十 二个月等等。如果把这些量说明为整型，字符型或其它类型显然是不妥当的。为此，C 语言提供了一种称 为“枚举”的类型。枚举类型就是其值可以被一一列举出来，并且变量的取值不能超过定义的范围。  
枚举类型的声明方式比较特殊，具体格式如下:
      enum 枚举名 {标识符1 = 整型常量1, 标识符2 = 整型常量2, ...};

在上述代码中，enum 表示声明枚举的关键字，枚举名表示枚举对象的名称。为了让读者更好的理解枚举类型的使用，接下来通过定义一个枚举类型来进行详细讲解 
      enum month { JAN=1, FEB=2, MAR=3, APR=4, MAY=5, JUN=6,JUL=7, AUG=8, SEP=9, OCT=10, NOV=11, DEC=12 };

在枚举中规定，如果不给标识符指定具体的值，会默认该标识符的值等于前一标识符的值加 1。因此 可以将上面的定义简化成: enum month{JAN=1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC};如果不指定第一个标识符对应的常量，则它的默认值是 0