### 实型变量

实型变量也可以称为浮点型变量，浮点型变量是用来存储小数数值的。在 C 语言中，浮点型变量分为 两种:单精度浮点数\(float\)、双精度浮点数\(double\)，但是 double 型变量所表示的浮点数比 float 型变 量更精确。表中举了两种不同浮点型数所占用的存储空间大小及取值范围

### IEEE 754
引用
https://blog.csdn.net/sinat_33248998/article/details/51828844
https://www.jb51.net/article/86719.htm
IEEE定义了多种浮点格式，但最常见的是三种类型：单精度、双精度、扩展双精度，分别适用于不同的计算要求。一般而言，单精度适合一般计算，双精度适合科学计算，扩展双精度适合高精度计算。一个遵循IEEE 754标准的系统必须支持单精度类型（强制类型）、最好也支持双精度类型（推荐类型），至于扩展双精度类型可以随意。  
C语言中float遵循IEEE 2.24 （单精度） double遵循IEEE64.53（双精度）

|  | 长度 | 符号 | 指数 | 尾数 | 有效位数 | 指数偏移 | 说明 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 单精度 | 32位 | 1 | 8 | 23 | 24 | 127 | 有1个隐含位 |
| 双精度 | 64位 | 1 | 11 | 52 | 53 | 1023 | 有1个隐含位 |
| 扩展双精度 | 80位 | 1 | 15 | 64 | 64 | 16383 | 没有隐含位 |

扩展双精度类型没有隐含位，因此它的有效位数与尾数位数一致，而单精度类型和双精度类型均有一个隐含位，因此它的有效位数比位数位数多一个。

IEEE标准通过指数将表示空间划分成了三大块：

1. 最小值指数（所有位全置0）用于定义0和弱规范数
2. 最大指数（所有位全值1）用于定义±∞和NaN（Not a Number）
3. 其他指数用于表示常规的数。

这样一来，最大（指绝对值）常规数的指数不是全1的，最小常规数的指数也不是0，而是1。

#### 单精度类型
无论是单精度还是双精度在存储中都分为三个部分：

1. 符号位(Sign) : 0代表正，1代表为负
2. 指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储
3. 尾数部分（Mantissa）：尾数部分

![](/CC++/C语言/images/float_32.png)
##### 表示范围
|  | 指数 | 尾数 | 数值 |
| :--- | :--- | :--- | :--- |
| 最大数 | 0xFE | 0x7FFFFF | 3.4028234663852886E+38 |
| 最小数 | 0x01 | 0x000000 | 1.1754943508222875E-38 |
| 最小弱规范数 | 0x00 | 0x000001 | 1.4012984643248171E-45 |

注意 **float double 绝对值最小的数值不是0，而是最小弱规范数**
##### 有效数字

单精度类型有24位有效位，因此有效数字是0.301×24=7.2，即单精度类型有7~8位有效数字


### 双精度类型
![](/CC++/C语言/images/float_64.png)
#### 表示范围
|  | 指数 | 尾数 | 数值 |
| :--- | :--- | :--- | :--- |
| 最大数 | 0x7FE | 0xFFFFFFFFFFFFF | 1.7976931348623157E+308 |
| 最小数 | 0x01 | 0x0000000000000 | 2.2250738585072014E-308 |
| 最小弱规范数 | 0x00 | 0x0000000000001 | 4.9406564584124654E-324 |


##### 有效数字
双精度类型有53位有效位，因此有效数字是0.301×53=15.9，即单精度类型有15~16位有效数字。

#### 扩展双精度类型
表面上看，常见的计算一般无需使用扩展双精度类型，因此扩展双精度类型很少见，但这很可能是个错觉。一些浮点硬件（例如 Intel x87 FPU）将扩展双精度类型作为内部格式，即在计算前，其他浮点格式均需转换为扩展双精度类型，然后才进行计算，在输出计算结果时，又将扩展双精度类型转换为其他格式。甚至可以说，扩展双精度类型是最常用的格式，只是一般用户不常见到而已。

#### 表示范围
|  | 指数 | 尾数 | 数值 |
| :--- | :--- | :--- | :--- |
| 最大数 | 0x7FFE | 0xFFFFFFFFFFFFFFFF | 1.18973149535723176E+4932 |
| 最小数 | 0x0001 | 0x0000000000000000 | 3.36210314311209552E-4932 |
| 最小弱规范数 | 0x0000 | 0x0000000000000001 | 1.82259976594123730E-4951\* |




### 分类
| 指数 |  | 隐含位 | 尾数 | 说明 |
| :--- | :--- | :--- | :--- | :--- |
| 111...111 | QNaN | 1 | 1XX...XXX | 尾数高位为1,但尾数不为0 |
|  | SNaN | 1 | 0XX...XXX | 尾数高位为0,但尾数不为0 |
|  | 无穷（∞） | 1 | 0 | 尾数不0 |
|  | 有限数 | 1 | XXX...XXX | 指数非0、非全1 |
| 000...000 | 弱规范数 |  | XXX...XXX | 没有隐含位，尾数不是0 |
|  | 零（0） | 0 | 0 | 尾数为0 |

##### 有限数

在这几类数中，有限数是最常用的，也是唯一以常规方式解释的数。有限数的特征是指数在最大值和最小值之间，且整数位恒是1。例如对于单精度类型，它的指数有8位，考虑偏移后，指数最大值是255，最小值是0，而有限数的指数就在[1，254]区间。整数位是隐藏的，恒是1。它的形式是：

$$±( 1 + f )*2^{E-OFFSET}$$

其中，E是指数，OFFSET是指数偏移，1是被隐含的整数位，f是尾数其他部分。

有限数的使用除了遵循数学规则之外，没有其它规则。当然，有些出于硬件考虑附加的限制是存在的，例如计算正弦函数的FSIN指令就对输入的数据范围施加了限制。

除了违反数学规则之外，在一般使用有限数的过程中，最常见的问题是溢出，即运算结果超出了有限数的表示范围。浮点数长度越小这个问题越常见，例如单精度类型。不过，只要稍微注意一下，一般不是大问题。


#### 0

0的特征是指数、尾数、整数位全0，只有符号位可能不是0。它的形式是：

$$±( 0 + 0 )×2^{0-OFFSET}$$

与数学中0无正负不同，IEEE 754标准定义的0有正负，即0有两种：+0和-0。之所以如此，有几个原因：

[1] 被零除通常产生无穷，而无穷有正负无穷两类；

[2] CopySign函数可以无需特别处理；

以上每个原因都不是绝对要求（毕竟，数学上0无正负就意味着0可以没有符号），但在软硬件实现上给0加上符号却带来一些方便。不过，这也意味着比较指令需要特别注意，因为+0和-0应相等，而不是+0大于-0。

##### 弱规范数
弱规范数的指数与0一样是0，它整数位也是0，但尾数部分不是0。它的形式是：

$$±( f )*2^{0-OFFSET}$$

但此处的f不局限于[0,1)，而是(0,2)。

IEEE标准引入弱规范数的目的是实现一种称为“逐渐下溢”的技术。在计算过程中，如果中间结果小于最小的有限数却不是0（即出现下溢），当作0处理会导致计算终止（例如病态矩阵）。引入弱规范数以后，在0和最小的有限数之间相当一部分数可以表示为弱规范数，从而提高了计算能力。例如单精度类型最小的有限数是1.1754943508222875E-38，而最小的弱规范数是1.4012984643248171E-45。

### ∞

∞的指数部分是最大值，整数位是1，尾数部分是0。它的形式是：

$$±( 1 + 0 )*2^{MAX-OFFSET}$$

因此∞有两类，即+∞和-∞。产生∞的一般情形有：

[1] ∞自身运算，例如-∞+1.0得到-∞；

[2] 被0除，例如1/+0得到+∞；

[3] 上溢，即计算结果超出了类型范围，通过舍入得到∞。

由于在一般数学中，∞是不能参与运算的，因此IEEE的这些规定可以说是某种扩展。

 

#### NaN

NaN的意思是Not a Number或者Not any number。NaN之所以显得比较奇怪，是因为数学上本没有这么一个数或符号，它纯粹是为了方便处理而提出来的，但它的历史可不短。早在三十年代后期就有人提出了类似NaN的概念。1963年的CDC 6600系统实现了它，但将它视为“没有定义”。后来，DEC的PDP-11和VAX系统也使用它，但将它用作“保留的操作数”。时至今日，虽然IEEE明确地定义了NaN，但在实际使用过程中，NaN经常被误解误用，需要特别小心。

与∞一样，NaN的指数部分是最大值，整数位是1，但它尾数部分不是0。它的形式是：

$$±( 1 + f )*2^{MAX-OFFSET}$$

其中，f≠0。

NaN有两类，一类是QNaN（Quiet NaN），一类是SNaN（Signal NaN）。两者的不同在于IEEE标准要求，如果SNaN参与运算要触发非法操作异常，而QNaN参与运算可以不触发异常。两者在格式上的区别在于，QNaN的尾数最高位是1，而SNaN的尾数最高位是0。一般情形下，如果不特别声明，NaN指的是QNaN。

IEEE标准引入NaN的目的是希望给编译器等系统一个约定的值设置未初始化的数据，或者在计算出问题时可以返回一个东西提示计算出现了问题。




