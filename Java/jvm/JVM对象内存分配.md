# 探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的过程

### 对象的创建（探讨普通Java对象，不包括数组和Class对象）
#### 加载类与查找类符号引用
* 虚拟机遇到new指令时，先检査指令的参数是否能在常量池中找到一个类的符号引用，然后检査这个符号引用代表的类是否已被加载、解析和初始化过，如果没有,就必须先执行相应的类加载过程。

#### 确定新对象的内存大小
* 在通过类加载检查后，虚拟机开始为新生对象分配内存。对象的大小在类加载完后确定，。

#### 分配对象内存空间
* 指针碰撞 : 假设Java堆中内存是绝对规整的，使用的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存时就把指针向空闲空间方向移动一段与对象大小相等的距离，这种分配方 式称为“指针碰撞”（Bump the Pointer）。

* 空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简牟地进行指针碰撞了，虚拟机维护一个负责记录可用内存块的表，分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List〉。

* 选择分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。在使用Serial、ParNew等带Compact过程的收集器时.系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。

##### 当分配对象内存空间线程并发情况
即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。

* 方案一：对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性：
* 方案二：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java-堆中预先分配一小块内存,称为本地线程分配缓冲.（Thread Local Allocation Buffer，TLAB）当线程要分配内存时， 就先在线程的TLAB上分配；只有TtAB用完并分配新的TLAB时，才需要同步锁定。

虚拟机是否使用TLAB,可以通过-XX:+/-UseTLAB参数来设定。

#### 初始化对象内存空间
* 内存分配完成后，除了对象头外，虚拟机将分配到的内存空间都初始化为零值

*如果使用TLAB,这一工作过程也可以提前至TLAB分配时进行。

初始化对象内存空间保证了对象的的实例字段在不赋初始值的情况下就可以直接使用,程序能访问到这些字段的数据类型对应的是零值

#### 初始化对象头
虚拟机需要对对象进行必要的设置，描述个对象的所属类的实例、索引类的元数据信息、对象的哈希值码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。

---
上面工作都完成之后，

* 在虚拟机角度看，一个新的对象已经产生
* 从Java程序的角度看,对象创建才刚开始。还未执行init方法,所有的字段都是零。



