# JAVA运行时内存区域


#### 程序计数器（Program Counter）
* 一块小的内存空间，当做当前线程执行直接骂的行号指示器，字节码解释器通过改变计数器的值来选取下一条需要执行的字节指令。
* 线程切换后，通过程序计数器恢复到正确的执行位置，每个线程拥有独立的程序计数器，独立存储互不影响，线程私有。
* 如果线程执行Java方法，计数器记录虚拟机字节码地址，如果执行Native方法，则计数器的值为Undefined。

###### 异常 
**Java虚拟机规范中唯一一个没有任何规定OutfMemoryError情况的区域**

#### Java虚拟机栈
* Java虚拟机栈也是线程私有，生命周期与线程相同
* java虚拟机栈描述Java方法执行的内存模型，每个方法在执行的同时会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接方法出口等信息。
* 每个方法从调用直至执行，就对应着一个栈帧在虚拟机中入栈到出栈的过程

##### 异常 

**1 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
2如果虚拟机栈可以动态扩展，遇到无法申请到足够的内存，就会抛出OutOfMemoryError**

##### 局部变量表
* 存放编译期可知的各种基本数据类型，对象引用和returnAddress类型
* 64位长度的long 和 double类型数据会占用2个局部变量空间（slot），其余数据类型只占一个。
* 局部变量表所需空间在编译期分配，运行期间不会改变局部变量表

### 本地方法栈 Native Method Stack
* 本地方法栈与虚拟机栈作用相似，本地方法栈为虚拟机使用Native方法服务
* 虚拟机规范中没有对本地方法栈使用的语言，方式，数据结构作强制规定
* HotSpot虚拟机中直接把本地方法栈与虚拟机栈合并

##### 异常
**与虚拟机栈一样
1 StackOverflowError
2 OutOfMemoryError**

### Java堆（Heap）
* 虚拟机所管理的内存中最大一块。
* Java堆被线程共享，在虚拟机启动的时候创建。
* 几乎所有对象实例以及数组都在堆上分配空间，但不是绝对。
* java堆又称GC堆， 垃圾收集管理器主要管理区域
* 从内存回收角度看，垃圾收集器采用分代收集短发，Java堆可以以细分：**新生代和老年代**，更细致还可分为**Eden空间， FromSurvivor空间， ToSurvivor空间**等。
* 从内存分配角度k按，线程共享的堆可能划分出多个**私有线程的分配缓冲区 TLAB（Thread Local Allocation Buffer**）
 ##### 异常 
 **堆中没有内存完成实例分配，且无法再扩展时，抛出OutOfMemoryError异常**
 
 ### 方法区（Method Area）
 * 各个线程共享内存区域，用于存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码数据等。
 * Java虚拟机规范把方法去描述为对的一个逻辑部分，但他且有一个别名叫做Non-Heap（非堆），目的应该是与Java区分开来
 * 习惯在HotSpot上开发的人常把方法区成为永久代（Permanent Generation），本质上两者并不等价，仅因为HotSpot爱发团队吧GC分代收集扩展至方法区，或者说用永久代实现方法区，这样垃圾收集器可以像管理堆的一样管理内存，省去专门为方法区写内存管理代码。
 * 对其它虚拟机来说不存在永久代的概念，使用永久带来实现方法区更容易遇到内存溢出问题
 * 虚拟机对方法区限制宽松，不许连续内存，可以固定大小或可扩展外，还可不实现垃圾收集器
 * 方法区垃圾收集器主要对常量池回收和类型卸载，回收效果不明显过
##### 异常
方法去内存无法满足内存分配需求时，抛出OutOfMemoryError异常

##### 运行常量池（Runtime Constant Pool）
* 属于方法区的一部分