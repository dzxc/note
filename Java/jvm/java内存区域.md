# JAVA运行时内存区域


#### 程序计数器（Program Counter）
* 一块小的内存空间，当做当前线程执行直接骂的行号指示器，字节码解释器通过改变计数器的值来选取下一条需要执行的字节指令。
* 线程切换后，通过程序计数器恢复到正确的执行位置，每个线程拥有独立的程序计数器，独立存储互不影响，线程私有。
* 如果线程执行Java方法，计数器记录虚拟机字节码地址，如果执行Native方法，则计数器的值为Undefined。

###### 异常 
**Java虚拟机规范中唯一一个没有任何规定OutfMemoryError情况的区域**

#### Java虚拟机栈
* Java虚拟机栈也是线程私有，生命周期与线程相同
* java虚拟机栈描述Java方法执行的内存模型，每个方法在执行的同时会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接方法出口等信息。
* 每个方法从调用直至执行，就对应着一个栈帧在虚拟机中入栈到出栈的过程

##### 异常 

**1 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
2如果虚拟机栈可以动态扩展，遇到无法申请到足够的内存，就会抛出OutOfMemoryError**

##### 局部变量表
* 存放编译期可知的各种基本数据类型，对象引用和returnAddress类型
* 64位长度的long 和 double类型数据会占用2个局部变量空间（slot），其余数据类型只占一个。
* 局部变量表所需空间在编译期分配，运行期间不会改变局部变量表

### 本地方法栈 Native Method Stack
* 本地方法栈与虚拟机栈作用相似，本地方法栈为虚拟机使用Native方法服务
* 虚拟机规范中没有对本地方法栈使用的语言，方式，数据结构作强制规定
* HotSpot虚拟机中直接把本地方法栈与虚拟机栈合并

##### 异常
**与虚拟机栈一样
1 StackOverflowError
2 OutOfMemoryError**

### Java堆（Heap）
* 虚拟机所管理的内存中最大一块。
* Java堆被线程共享，在虚拟机启动的时候创建。
* 几乎所有对象实例以及数组都在堆上分配空间，但不是绝对。
* java堆又称GC堆， 垃圾收集管理器主要管理区域
* 从内存回收角度看，垃圾收集器采用分代收集短发，Java堆可以以细分：**新生代和老年代**，更细致还可分为**Eden空间， FromSurvivor空间， ToSurvivor空间**等。
* 从内存分配角度k按，线程共享的堆可能划分出多个**私有线程的分配缓冲区 TLAB（Thread Local Allocation Buffer**）
 ##### 异常 
 **堆中没有内存完成实例分配，且无法再扩展时，抛出OutOfMemoryError异常**
 
 ### 方法区（Method Area）
 * 各个线程共享内存区域，用于存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码数据等。
 * Java虚拟机规范把方法去描述为对的一个逻辑部分，但他且有一个别名叫做Non-Heap（非堆），目的应该是与Java区分开来
 * 习惯在HotSpot上开发的人常把方法区成为永久代（Permanent Generation），本质上两者并不等价，仅因为HotSpot爱发团队吧GC分代收集扩展至方法区，或者说用永久代实现方法区，这样垃圾收集器可以像管理堆的一样管理内存，省去专门为方法区写内存管理代码。
 * 对其它虚拟机来说不存在永久代的概念，使用永久带来实现方法区更容易遇到内存溢出问题
 * 虚拟机对方法区限制宽松，不许连续内存，可以固定大小或可扩展外，还可不实现垃圾收集器
 * 方法区垃圾收集器主要对常量池回收和类型卸载，回收效果不明显过
##### 异常
方法去内存无法满足内存分配需求时，抛出OutOfMemoryError异常

##### 运行常量池（Runtime Constant Pool）
* 属于方法区的一部分
* Class文件中除了有类的版 本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于 存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进人方法区的运行时常 量池中存放。

* Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运 行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照 自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

* 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java不要求常量一定只有编译期才能产生，可以动态添加常量到运行时常量池中，这种特性被开发人员利用得 比较多的便是String类的intem()方法。

##### 异常
**当常量池无法再申请到内存时会抛出OutOfMemoryError异常。**

### 直接内存（Direct Memory）
* 并不是虚拟机运行时数据区的一部分，也不属于Java虚拟机规范中定义的内存区域。

* JDK 1.4中新加人了 NIO （New Input/Output）类，引人了一种基于通道（Channel） 与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一 个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。某些场景下提髙性能，避免了在Java堆和Native堆中来回复制数据，

* 本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是 会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。

##### 异常
**服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制）， 从而导致动态扩展时出现OutOfMemoryError异常。
**


