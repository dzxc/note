# 对象内存布局
HotSpot虚拟机中，对象在内存中布局分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

### 对象头（Header）
HotSpot虚拟机的对象头有两部分信息：
##### 第一部分 用于存储对象自身的运行时数据，如哈希码（HashCode）, GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等。

这部分数据在32位和64位的虚拟机（未开启压缩指针）中的长度分别为32bit和 64bit,官方称它为“Mark Word”。

对象需要存储的运行时数据很多，其实已经超出了 32位、 64位Bitmap结构所能记录的限度，因此Mark Word被设计成一个非固定的数据结构，以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。

例如，在32位的 HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中的
25bit 用于存储对象哈希码，
4bit用于存储对象分代年龄，
2bit用于存储锁标志位，
1bit固定为0, 
而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）

|存储内容 |标志位 |状 态|
|---||
|对象哈希码、对象分代年龄|01 |未锁定|
|指向锁记录的指针|00|轻量级锁定|
|指向重量级锁的指针|10|膨胀（S量级锁定）|
|空，不需要记录信息|11|GC标记|
|偏向线程ID、偏向时间戳、对象分代年龄|01|可偏向|

##### 第二部分是类型指针，即对象指向它的类元数据的指针

* 虚拟机通过这个指针来判断对象是属于那个类。
**并非所有的虚拟机都实现在对象数据上保留类型指针，**

* Java数组对象的对象头必须有一块用于记录数组长度的空间，虚拟机通过普通对象的元数据确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。

### 实例数据（Instance Data）

* 实例数据存储的是类中定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

* 这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和Java源码中定义字段顺序的影响。

* HotSpot虚拟机默认的分配策略为：
longs/doubles、 ints、 shorts/chars、 bytes/ booleans、oops （Ordinary Object Pointers）。

* 从分配策略中可以看出，相同宽度的字段总是被分配到一起。**在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前**。
* 如果 CompactFields参数值为true （默认为true）,那么子类之中较窄的变量也可能会插人到父类 变量的空隙之中，

### 对齐填充
对齐填充并不是必然存在的，仅仅作占位符的作用。 
* 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象的大小必须是8字节的整数倍。当对象实例数据部分没有对齐时，通过对齐填充来补全。

# 对象的访问定位
Java程序通过栈上的reference数据来操作堆上的具体对象。Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式 也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。

### 使用句柄访问

![](/Java/jvm/images/1.jpg)

* Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体。

* 使用句柄来访问的最大好处就是reference中存储的是稳 定的句柄地址，在对象被移动时只改变句柄中的实例数据指针，而reference本身不需要修改。



### 直接指针访问

![](/Java/jvm/images/2.jpg)

* 使用直接指针访问方式速度快，它节省了一次指针定位的时间开销， 由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。
* 虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的



