### 引用类型
在JDK1.2之后，Java对引用的概念进行了扩充，将引用分4 种，这 4种引用强度依次逐渐减弱。
* 强引用(StrongReference)
* 软引用(Soft Reference)
* 弱引用(Weak Reference)
* 虚引用(Phantom Reference)

##### 强引用
指在程序代码之中普遍存在的引用，类似"Object obj = new Object()”这类的 引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

##### 软引用
软引用用来描述一些还有用但并非必需的对象。
* 对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，将会拋出内存溢出异常。

##### 弱引用
用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

##### 虚引用
虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。**一个对象是否省虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。**为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一 个系统通知。

### 对象回收过程

##### 第一次标记
* 当对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第1次标记并且进行一次筛选。

* 筛选的条件是这个对象是否有必要执行finalize()方法。如果对象没有覆盖finalize()方法，或是finalize()方法已经被虚拟机调用过，虚拟机将这两种悄况都视为“没有必要执行”。

##### 执行finalize()
* 如果这个对象被判定为有必要执行finalize()方法，这个对象将会放在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执 行它。

* 虚拟机会调用finalize方法，但不保证会将它执行完，或等待它运行结束，原因是，如果一个对象在finalizeO方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。

##### 第二次标记
* GC将对F-Queue中的对象 进行第二次小规模的标记,如果对象在finalize()中重新与引用链上的一个对象建立关联，那在第二次标记时它将被移除出“即将回收”的集合；
* 如果对象这时候没有与当一个对象到GC Roots没有任何引用链相连时， 基本上它会被回收了。

finalize方法与C/C++中的析构函数不同，Java诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价髙昂，不确定性大，无法保证各个对象的调用顺序。所以不推荐使用这个方法。

### 回收方法区
Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低；

##### 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

判断废弃常量。
* 如果一个常量没有被链接到GC Roots引用链上，这时发生内存回收，而且必要的话，常量就会被系统清理出常量池。常量池中的其 他类（接口）、方法、字段的符号引用也与此类似。

判断无用的类需要同时满足下面3个条件：

* 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。

* 加载该类的ClassLoader已经被回收。

* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访 问该类的方法。

虚拟机可以对满足上述3个条件的无用类进行回收，但不一定就会被回收。

HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用
-verbose:class 以及-XX:+TraceClassLoading、
-XX:+TraceClassUnLoading 査看类加载和知载信息，
-vobose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，
-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。

---

#### 
* 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。