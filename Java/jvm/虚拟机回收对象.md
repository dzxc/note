# 虚拟机回收对象细节

### 枚举根节点

* 直接从GC Roots节点找引用链进行可达性分析费时费力。现在设备运行存储空间都比较大，Java应用内存占用也是比较多的，有的仅仅方法区就有数百兆，如果要逐个检査这里面的引用来实现可达性分析，从GC Roots节点找引用链这个操作会消耗很多的资源和时间。这种方式称为保守式GC，

* 可达性分析对执行时间的敏感还体现在GC停顿上。因为分析工作要确保状态一致性，需要是整个Java虚拟机停下任务来进行分析。不可以出现分析过程中对象引用关系还在不断变化的情况。（Sun将这件事情称为“Stop-The-World’），即使是号称（几乎）不会发生停顿CMS收集器中枚举根节点时也是必须要停顿的。

虚拟机使用一组称为OopMap的数据结构记录对象内引用类型数据的位置，虚拟机在类加载完后就把对象内将字段的偏移量上的类型计算出来，JIT编译过程中也会在特定的位置记录下栈和寄存器中哪砦位置是引用。这样GC在扫描时就可以直接得知这些信息了。不需要一个不漏地检査完所。这种方式称为准确式GC。

### 安全点

* OopMap可以帮助虚拟机可以快速且准确地完成GC Roots枚举，如果为每一条指令都生成对应的OopMap,那将会需要大量的额外空间。

* OopMap会在特定的点上记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用。这样GC在扫描栈的时候就会查询这些OopMap就知道哪里是引用了。这些特定的位置主要在：

  ```
     1、循环的末尾 
     2、方法临返回前 / 调用方法的call指令后 
     3、可能抛异常的位置
  ```

  这些特定的位置称为安全点\(Safepoint\)

如何在GC发生时让所有线程\(这里不包括执行JNI调用的线程\)都执行到最近的安全点上停顿下来。  
这里有两种方案可供选择：

* 抢先式中断\(Preemptive Suspension\)：
  抢先式中断 不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有 线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机 实现采用抢先式中断来暂停线程从而响应GC亊件。

* 主动式中断\(Voluntary Suspension\)：
  思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，让各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。 轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方

#### 安全区域
当线程没有获得CPU执行权时，线程处就可能处于Sleep状态或者Blocked状态，无法响应JVM的中断请求，就需要安全区域(Safe Region)来解决。

#### 安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方 开始GC都是安全的。
在离开安全区域前判断，虚拟机是否已经完成GC，如果完成就离开，未完成则继续等待。
* 在线程执行到Safe Region中的代码时，首先标识自己已经进人了 Safe Region，那样当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。

* 在线程要离 开Safe Region时，它要检査系统是否已经完成了根节点枚举（或者是整个GC过程〉，如果完 成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。



