# 虚拟机类加载机制

#类加载的时机
类的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading） 7个阶段。其中验证、准备、解析3个 部分统称为连接（Linking）。

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。


### 触发开始类加载过程的情况
Java虚拟机规范中并没有进行强制约束。但是对于初始化阶段，虚拟机规范则 是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需 要在此之前开始）：

有且只有以下5种情况：

1. 创建新对象（new）、设置/读取static字段(putstatic/getstatic)或调用静态方法（invokestatic）这四条指令时，如果该类没有初始化，则初始化。
2. 使用java.lang.reflect包得方法进行反射调用的时候，如果该类没有初始化，则初始化。
3. 当初始化一个类时，父类没有初始化，则先初始化父类。
4. 当虚拟机启动，需要执行main()的主类，JVM首先初始化该类。
5. JDK 1.7的动态语言支持时，如果java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则初始化。

对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语： “有且只有”，这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方 式都不会触发初始化，称为被动引用。

需要开始接口加载过程的：接口与类真正有所区别的是前面讲述的5种 “有且仅有"需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已 经初始化过了.但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在 真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

## 类加载的过程
类加载过程包括加载（Loading）、链接（Linking）和初始化（Initialization）三个过程。
![](/Java/jvm/images/13.png)

### 加载（Loading）
其中“根据全限定名获取字节流”的过程，可以有系统提供的类加载器完成，也可以由用户自定义类加载器。
对于HotSpot，Class对象虽然是对象，但仍然存放在方法区中。
#### 链接-准备
该阶段值正式在方法区为类变量分配内存初始化类变量，
public static int value = 123
在准备阶段初始化零值，而非123。初始化123的过程在初始化阶段完成。
#### 链接-解析
将常量池中的符号引用替换成直接引用。其中对于非虚方法，在类加载阶段就可以确定调用的版本，因此可以在此阶段直接解析为直接引用；为对于虚方法（即支持多态），无法在此阶段确定调用版本，虚方法的符号引用需等到程序执行到该符号引用的字节码时才能解析为直接引用。
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法类型等符号引用。
执行读写字段（getstatic、putstatic、getfield、putfield）、instanceof、方法调用（iinvokestatic、invokespecial、invokevirtual、invokedynamic）、new等操作符号引用的字节码之前，需要先进行符号引用解析。
### 初始化（Initialization）
执行类构造器<clinit>：自动收集static变量和static{}块，按原文件出席西安的顺序执行初始化。
<clinit>由编译器自动生成，如果没有static变量和static{}块，就不会生成。